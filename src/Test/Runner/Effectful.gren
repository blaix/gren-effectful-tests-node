module Test.Runner.Effectful exposing 
    ( Program

    -- TESTS
    , Test
    , test
    , concat
    , describe
    , init

    -- TASKS
    , await
    , awaitError

    -- RUN
    , run
    , thenRun
    -- TODO: runWithOptions
    )


import Expect exposing (Expectation)
import Init
import Node
import Random
import Task exposing (Task)
import Terminal
import Test
import Test.Runner.Log as Log
import Test.Runner.Node
import Time


{-| Type alias for a program that runs your effectful [Test](#Test) suite.
-}
type alias Program a =
    Node.SimpleProgram a


{-| Alias for a test in an effectful test suite.

You can create Tests with [test](#test) and wrap them in 0 or more [await](#await)s.
-}
type alias Test =
    Task Never (InternalTest {})


type InternalTest a
    = Box a
    | Ready Test.Test


unwrap : InternalTest a -> Test.Test
unwrap internalTest =
    when internalTest is
        Ready t ->
            t
        Box _ ->
            -- This should never happen...
            -- Any way to refactor it away?
            Test.test "Unexpected error" <| \_ ->
                Expect.fail
                    """
                    Oops! Something weird happened and you reached a point in
                    the code that I thought was unreachable. Congrats! But
                    also... sorry about that. It would be great if you could
                    open an issue so I can figure out how this happened:
                    https://github.com/blaix/gren-effectful-tests-node/issues
                    Please include the test(s) that triggered this error.
                    """


-- CREATING TESTS


{-| Create a standard test. Semantics are the same as `test` from the
[core package](https://packages.gren-lang.org/package/gren-lang/test/version/latest/module/Test#test):

    test "my test" <| \_ ->
        Expect.equal True True

except it can optionally be nested in an [await](#await):

    await Time.now "The current time" <| \now ->
        test "is not Jan 1, 1970" <| \_ ->
            Expect.notEqual (Time.millisToPosix 0) now

Note: with this runner, you must use this test function,
not the test function from the core package.
-}
test : String -> ({} -> Expectation) -> Test
test description thunk =
    Test.test description thunk
        |> Ready
        |> Task.succeed


{-| Group an array of [Test](#Test)s into one.

Passing an empty array will result in a failing test, because you either made a mistake or are creating a placeholder.
-}
concat : Array Test -> Test
concat tests =
    tests
        |> Array.map (Task.map unwrap)
        |> Task.sequence
        |> Task.map Test.concat
        |> Task.map Ready


{-| Group an array of [Test](#Test)s with a description.

Passing an empty array will result in a failing test, because you either made a mistake or are creating a placeholder.
-}
describe : String -> Array Test -> Test
describe description tests =
    tests
        |> Array.map (Task.map unwrap)
        |> Task.sequence
        |> Task.map (Test.describe description)
        |> Task.map Ready


-- RESOLVING TASKS


{-| Wait for a task to resolve before running a test.

    await Time.now "Current time" <| \now ->
        test "is not Jan 1, 1970" <| \_ ->
            Expect.notEqual (Time.millisToPosix 0) now

If the task fails, the inner test won't run and the test suite will fail.
If you want to test the error condition of a task, use [awaitError](#awaitError).

You can nest as many awaits as you want:

    await (Task.succeed "a") "task a" <| \a ->
    await (Task.succeed "b") "task b" <| \b ->
        test "are not equal" <| \_ ->
            Expect.notEqual a b
-}
await : Task error a -> String -> (a -> Test) -> Test
await task description callback =
    task
        |> Task.map Box
        |> Task.onError 
            (\e -> 
                (\_ -> Expect.fail ("Task failed with: " ++ (Debug.toString e)))
                    |> Test.test description
                    |> Ready
                    |> Task.succeed
            )
        |> Task.andThen (map callback)
        -- TODO: am I double wrapping description?
        |> Task.andThen (wrapDescription description)


{-| Test the error state of a task.

    awaitError (Task.fail "oopsy") "An expected failure" <| \error ->
        test "is an oopsy" \_ ->
            Expect.equal "oopsy" error

If the task does not fail, the inner test won't run and the test suite will fail.

These can be nested just like and alongside [await](#await)s.
-}
awaitError : Task error a -> String -> (error -> Test) -> Test
awaitError task description callback =
    task
        |> Task.map Box
        |> Task.andThen 
            (\a -> 
                (\_ -> Expect.fail ("Expected error, but got non-error value: " ++ (Debug.toString a)))
                    |> Test.test description
                    |> Ready
                    |> Task.succeed
            )
        |> Task.onError callback
        -- TODO: am I double wrapping description?
        |> Task.andThen (wrapDescription description)


map : (a -> Test) -> InternalTest a -> Test
map fn internalTest =
    when internalTest is
        Box a ->
            fn a
        Ready t ->
            Task.succeed (Ready t)


wrapDescription : String -> InternalTest a -> Test
wrapDescription description internalTest =
    internalTest
        |> unwrap
        |> Array.singleton
        |> Test.describe description
        |> Ready
        |> Task.succeed


-- RUNNING TESTS


{-| Create a program that runs your effectful [Test](#Test) suite.

This will normally be used as your `main` function:

    main =
        run <|
            await (Task.succeed "hi") "my task" <| \val ->
                test "my test" <| \_ ->
                    Expect.equal "hi" val

Note: The test suite must be created with the test functions from this package,
not the core test package.
-}
run : Test -> Program a
run t =
    Node.defineSimpleProgram <| \env ->
        thenRun env t


{-| Gives your test suite access to
[Node.Environment](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#Environment)
and [subsystem permissions](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Init).

This call will wrap your test suite, which will need to be run with
[thenRun](#thenRun) instead of [run](#run). For example:

    main =
        init <| \env ->
            FileSystem.initialize <| \fsPerm ->
            HttpClient.initialize <| \httpPerm ->
                thenRun env <|
                    await (myReadTask fsPerm) "read file" <| \contents ->
                    await (myHttpTask httpPerm) "send contents" <| \response ->
                        test "is successfull" <| \_ ->
                            Expect.equal 200 response.statusCode
-}
init : (Node.Environment -> Init.Task (Cmd a)) -> Program a
init =
    Node.defineSimpleProgram


{-| Define the [Test](#Test) suite that should run after initializing subsystems.

The semantics of this functino are equivalent to [run](#run),
except it takes [Node.Environment](https://packages.gren-lang.org/package/gren-lang/node/version/latest/module/Node#Environment)
in addition to the test suite.
-}
thenRun : Node.Environment -> Test -> Init.Task (Cmd a)
thenRun env testTask =
    Init.await Terminal.initialize <| \termConfig ->
    Init.awaitTask Time.now <| \time ->
    Init.awaitTask testTask <| \t ->
        Node.endSimpleProgram <|
            Log.run
                { test = unwrap t
                , runs = 100
                , passStream = env.stdout
                , failStream = env.stderr
                , colorDepth = getColorDepth termConfig 
                , seed = Random.initialSeed (Time.posixToMillis time)
                }


-- UTIL


getColorDepth : Maybe Terminal.Configuration -> Int
getColorDepth config =
    when config is
        Just { colorDepth } ->
            colorDepth
        Nothing ->
            1 -- lowest color depth (no colors)
